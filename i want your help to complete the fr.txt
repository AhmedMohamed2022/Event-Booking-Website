i want your help to complete the front end of a project i'm currently implementing using Angular 19 with Node js . i need you to fully read these instructions and explanations for the project and what i have done so far "# Event Booking Platform - Complete Project Specifications ## Project Overview I'm building an event booking mobile-first responsive website for a client. The project consists of a Node.js backend (already completed) and an Angular 19 frontend using standalone components only. ## Backend Stack (Already Completed) - Node.js with Express - MongoDB with Mongoose - API Endpoints: 

### Page to implement

 Admin Dashboard

Show:

Total users

Total bookings

Total revenue

ðŸ“¡ API: GET /api/admin/stats

ðŸ“¡ API: GET /api/join (get supplier requests)

ðŸ” Admin token required

Responses include total users, bookings, revenue, etc.

ðŸ” Public

Models Schema** (in the backend):

const mongoose = require("mongoose");  const userSchema = new mongoose.Schema(   {     name: { type: String, required: true },     phone: { type: String, required: true, unique: true },     role: {       type: String,       enum: ["client", "supplier", "admin"],       default: "client",     },     isLocked: {       type: Boolean,       default: false,     },     bookingCount: {       type: Number,       default: 0,     },   },   { timestamps: true } );  module.exports = mongoose.model("User", userSchema); 

const mongoose = require("mongoose");

const joinRequestSchema = new mongoose.Schema({
  name: { type: String, required: true },
  phone: { type: String, required: true },
  serviceType: { type: String }, // optional (e.g., Hall, Decoration...)
  city: { type: String },
  notes: { type: String },
  status: {
    type: String,
    enum: ["pending", "reviewed", "approved", "rejected"],
    default: "pending",
  },
  createdAt: {
    type: Date,
    default: Date.now,
  },
});

module.exports = mongoose.model("JoinRequest", joinRequestSchema);


#routes Configuration: 

const express = require("express");
const router = express.Router();
const { getAdminStats } = require("../controllers/adminController");
const authMiddleware = require("../middleware/auth");
const adminOnly = require("../middleware/adminOnly");
const { unlockSupplier } = require("../controllers/adminController");

router.patch("/unlock/:id", authMiddleware, adminOnly, unlockSupplier);
router.get("/stats", authMiddleware, adminOnly, getAdminStats);

module.exports = router;
const express = require("express");
const router = express.Router();

const {
  submitJoinRequest,
  getJoinRequests,
  approveJoinRequest,
  rejectJoinRequest,
  markAsReviewed,
} = require("../controllers/joinController");

const authMiddleware = require("../middleware/auth");
const adminOnly = require("../middleware/adminOnly");
// Admin-only middleware

// Public
router.post("/", submitJoinRequest);

// Admin
router.get("/", authMiddleware, adminOnly, getJoinRequests);
router.patch("/:id/approve", authMiddleware, adminOnly, approveJoinRequest);
router.patch("/:id/reject", authMiddleware, adminOnly, rejectJoinRequest);
router.patch("/:id/review", authMiddleware, adminOnly, markAsReviewed);

module.exports = router;

##middlewares

module.exports = (req, res, next) => {
  if (!req.user || req.user.role !== "admin") {
    return res.status(403).json({ message: "Access denied. Admins only." });
  }
  next();
};


const jwt = require("jsonwebtoken"); const User = require("../models/User");  const authMiddleware = async (req, res, next) => {   const token = req.header("Authorization")?.replace("Bearer ", "");    if (!token) {     return res       .status(401)       .json({ message: "Access denied. No token provided." });   }    try {     const decoded = jwt.verify(token, process.env.JWT_SECRET);     req.user = await User.findById(decoded.id);     next();   } catch (error) {     res.status(400).json({ message: "Invalid token." });   } };  module.exports = authMiddleware; ##utils 

-subscription.js

// utils/subscription.js  const categoriesWithLimit = ["Hall", "Farm", "Salon"];  function shouldEnforceLimit(category) {   return categoriesWithLimit.includes(category); }  function shouldLockSupplier(supplier) {   return supplier.bookingCount >= 50; }  

-notification

module.exports = { shouldEnforceLimit, shouldLockSupplier };
module.exports = {
    sendBookingConfirmation: (userEmail, bookingDetails) => {
        // Logic to send booking confirmation notification to the user
        console.log(`Sending booking confirmation to ${userEmail} with details:`, bookingDetails);
    },
    
    sendEventReminder: (userEmail, eventDetails) => {
        // Logic to send event reminder notification to the user
        console.log(`Sending event reminder to ${userEmail} for event:`, eventDetails);
    },
    
    sendCancellationNotice: (userEmail, bookingId) => {
        // Logic to send cancellation notice to the user
        console.log(`Sending cancellation notice to ${userEmail} for booking ID: ${bookingId}`);
    }
};

// utils/whatsapp.js

const sendWhatsAppNotification = async (phoneNumber, message) => {
  console.log(`ðŸ“² Sending WhatsApp message to ${phoneNumber}:`);
  console.log(`   "${message}"`);
  // ðŸ”’ Real integration with Twilio/360Dialog would go here
};

module.exports = sendWhatsAppNotification;

## controllers:

AdminController.js:

const User = require("../models/User"); const EventItem = require("../models/EventItem"); const Booking = require("../models/Booking");  exports.getAdminStats = async (req, res) => {   try {     const [       totalUsers,       totalSuppliers,       totalServices,       totalBookings,       confirmedBookings,       cancelledBookings,       revenueAgg,       topCategories,     ] = await Promise.all([       User.countDocuments({}),       User.countDocuments({ role: "supplier" }),       EventItem.countDocuments(),       Booking.countDocuments(),       Booking.countDocuments({ status: "confirmed" }),       Booking.countDocuments({ status: "cancelled" }),       Booking.aggregate([         { $match: { status: "confirmed" } },         { $group: { _id: null, total: { $sum: "$paidAmount" } } },       ]),       EventItem.aggregate([         { $group: { _id: "$category", count: { $sum: 1 } } },         { $sort: { count: -1 } },         { $limit: 5 },       ]),     ]);      const totalRevenue = revenueAgg[0]?.total || 0;      res.json({       totalUsers,       totalSuppliers,       totalServices,       totalBookings,       confirmedBookings,       cancelledBookings,       totalRevenue,       topCategories,     });   } catch (err) {     console.error("âŒ Admin stats failed:", err);     res.status(500).json({ error: "Failed to load admin statistics" });   } };  exports.unlockSupplier = async (req, res) => {   try {     const supplier = await User.findById(req.params.id);      if (!supplier || supplier.role !== "supplier") {       return res.status(404).json({ message: "Supplier not found" });     }      supplier.isLocked = false;     supplier.bookingCount = 0;      await supplier.save();      res.json({ message: "Supplier has been unlocked successfully." });   } catch (er) {     console.error(err);     res.status(500).json({ error: "Failed to unlock supplier" });   } };

joinController:

 const JoinRequest = require("../models/JoinRequest"); const User = require("../models/User");  // Submit join request (public) exports.submitJoinRequest = async (req, res) => {   try {     const { name, phone, serviceType, city, notes } = req.body;      const existing = await JoinRequest.findOne({ phone, status: "pending" });     if (existing) {       return res.status(400).json({ message: "Request already submitted" });     }      const request = await JoinRequest.create({       name,       phone,       serviceType,       city,       notes,     });      res.status(201).json({       message: "Join request submitted successfully",       request,     });   } catch (err) {     console.error(err);     res.status(500).json({ error: "Failed to submit join request" });   } };  // View all join requests (optional filter) exports.getJoinRequests = async (req, res) => {   try {     const filter = {};     if (req.query.status) {       filter.status = req.query.status;     }      const requests = await JoinRequest.find(filter).sort({ createdAt: -1 });     res.json(requests);   } catch (err) {     res.status(500).json({ error: "Failed to load join requests" });   } };  // Approve request â†’ create a supplier account exports.approveJoinRequest = async (req, res) => {   try {     const request = await JoinRequest.findById(req.params.id);      if (!request) return res.status(404).json({ message: "Request not found" });      if (request.status === "approved") {       return res.status(400).json({ message: "Request already approved" });     }      // Auto-create supplier user if not already registered     const existingUser = await User.findOne({ phone: request.phone });     if (!existingUser) {       await User.create({         name: request.name,         phone: request.phone,         role: "supplier",         password: Math.random().toString(36).substring(2, 10), // temporary       });     }      request.status = "approved";     await request.save();      res.json({ message: "Request approved and supplier account created." });   } catch (err) {     console.error(err);     res.status(500).json({ error: "Approval failed" });   } };  // Reject request exports.rejectJoinRequest = async (req, res) => {   try {     const request = await JoinRequest.findById(req.params.id);     if (!request) return res.status(404).json({ message: "Request not found" });      request.status = "rejected";     await request.save();      res.json({ message: "Request rejected." });   } catch (err) {     res.status(500).json({ error: "Failed to reject request" });   } };  // Mark request as reviewed exports.markAsReviewed = async (req, res) => {   try {     const request = await JoinRequest.findById(req.params.id);     if (!request) return res.status(404).json({ message: "Request not found" });      request.status = "reviewed";     await request.save();      res.json({ message: "Request marked as reviewed." });   } catch (err) {     res.status(500).json({ error: "Failed to update request" });   } }; # Frontend Stack & Architecture - Angular 19 with standalone components ONLY - Bootstrap for responsive design - Angular Router with lazy loading - HttpClient for API calls - FormsModule for form handling - No complex Angular features - keep it simple ### Angular 19 File Structure: src/ â”œâ”€â”€ app/ â”‚ â”œâ”€â”€ core/ â”‚ â”‚ â”œâ”€â”€ services/ (singleton services, guards, interceptors) â”‚ â”‚ â””â”€â”€ models/ (TypeScript interfaces matching backend) â”‚ â”œâ”€â”€ shared/ (reusable components, directives, pipes) â”‚ â”œâ”€â”€ features/ (each feature has its own folder) â”‚ â”‚ â”œâ”€â”€ home/ â”‚ â”‚ â”œâ”€â”€ search-result/ â”‚ â”‚ â””â”€â”€ service-detail/ â”‚ â”œâ”€â”€ layout/ (header, footer, sidebar components) â”‚ â””â”€â”€ environments/ â””â”€â”€ public/ (replaces assets folder in Angular 19) ## Design System & Theme ### Color Palette (Earth-tone): - 60% White: #ffffff (primary-white) - 30% Dark Gray: #2c2c2c (primary-dark) - 10% Gold: #ffc107 (accent-gold) - Supporting Colors: - Light Gray: #f8f9fa - Text Muted: #6c757d - Border Color: #e9ecef ### Design Principles: - Mobile-first responsive design - Clean, modern UI with smooth animations - Card-based layouts with subtle shadows - Consistent spacing and typography - Bootstrap utility classes for styling - Hover effects and micro-interactions ## Development Guidelines 1. Use only Angular 19 features - no older version syntax 2. Standalone components only - no modules 3. Keep code simple - avoid complex Angular patterns 4. Use Input/Output with EventEmitter for component communication 5. Use HttpClient for API calls 6. Use RouterLink and router navigation for routing 7. Follow the exact backend API structure 8. Maintain consistent earth-tone design 9. Ensure mobile-first responsive design 10. Use Bootstrap classes for styling ", and make each code at separate files (.html,.css,.ts,.service.ts,...etc) and please make the code as simple as possible but follow best practices and make the result correct and work without any problems for the endUser OK? so do what you see better and start implementation following the instructions i gave you all in separate files (pages ".ts,.html,.css,.service.ts,...etc") without diverting from them and structure i'm already using ok , and keep it as simple as possible?

 